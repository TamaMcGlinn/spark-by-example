# Created 2018-11-09 Fri 22:38
#+OPTIONS: author:nil title:nil toc:nil
#+EXPORT_FILE_NAME: ../../../mutating/Random_Shuffle.org

* The Random_Shuffle algorithm

The ~Random_Shuffle~ algorithms aims to randomly rearranges the
elements of an array. Its signature is:

#+BEGIN_SRC ada
  procedure Random_Shuffle (A : in out T_Arr)
#+END_SRC

** Formal specification and predicates used

We will first give a formal specification for ~Random_Shuffle~ and
define several predicates that will help us in the proof of this
function.

*** The predicate Multiset_Unchanged

As mentioned earlier, ~Random_Shuffle~ should rearrange the
elements of ~A~ in a "random" order. That being said, it is not
easy to mathematically define what a true random rearrangement
is, so we will only require that ~Random_Shuffle~ acts as a
permutation: the number of occurrences of each element of ~A~
remains constant when calling ~Random_Shuffle~.

We define a predicate ~Multiset_Unchanged~ which checks whether
two arrays are a permutation of each other, i.e. each element of
the first array have the same occurrences in the second array,
but not necessarily in the same order. The predicate is defined
with the help of the ~Occ~ predicate, defined in chapter 3 for
the [[file:../non-mutating/Count.org][Count]] function. ~Multiset_Unchanged~ is defined as follows:

#+BEGIN_SRC ada
  function Multiset_Unchanged
    (A : T_Arr;
     B : T_Arr)
     return Boolean is (for all K in T => Occ (A, K) = Occ (B, K)) with
     Pre => A'Length = B'Length;
#+END_SRC

Here we simply check that given two arrays ~A~ and ~B~ of same
length, the number of occurrences of a given ~T~ value is the
same for both arrays. It is important to check the property on
all elements of ~T~ and not only on the elements of ~A~,
otherwise the solvers cannot determine that we can obtain ~B~ by
permuting the elements of ~A~ and vice-versa.

*** Formal specification of Random_Shuffle

Given ~Multiset_Unchanged~, the specification of ~Random_Shuffle~
is the following:

#+BEGIN_SRC ada
  procedure Random_Shuffle (A : in out T_Arr) with
     Post => Multiset_Unchanged (A'Old, A);
#+END_SRC

The postcondition ensures that the elements of ~A~ are simply
permuted by ~Random_Shuffle~.

** Implementations of Random_Shuffle

In this section we give several implementations for
~Random_Shuffle~, starting by the easiest one, which cannot be
proved by the SMT solvers, and we progressively explain what can
be done in order to help the automatic provers to prove
everything.

*** First implementation

The first implementation makes use of the [[Swap.Org][Swap]] function proved
earlier in this chapter. We also assume that we have a function
~Random_Number~ which returns a number selected randomly between
two given bounds. As mentioned earlier, we will not focus on this
function, as our specification for ~Random_Shuffle~ has no real
constraints on the "randomness" of the function. Our first
implementation is defined as follows:

#+BEGIN_SRC ada
  procedure Random_Shuffle (A : in out T_Arr) is
        J : Positive;
     begin
  
        for I in A'Range loop
  	 J := Random_Number(A'First, I);
  	 Swap(A(I),A(J));
  
  	 pragma Loop_Invariant(Multiset_Unchanged(A,A'Loop_Entry));
  
        end loop;
  end Random_Shuffle;
#+END_SRC

There are a few issues with this implementation:
- using of ~Swap~ on an array introduces aliasing warnings
- solvers cannot automatically prove that swapping two elements
  of an array is a permutation, so the only loop invariant cannot
  be proved.

We have already encountered the first problem, and an easy
workaround is to manually do the swap with an intermediary
variable. However, it does not help to prove the loop
invariant. We have to write lemmas to help the solvers understand
that swapping two values in an array is a permutation.

*** Manual proof with lemmas

We here help the solvers prove our function by adding a manual
proof in the form of ghost code. This section makes use of the
examples given in the SPARK User's Guide on [[http://docs.adacore.com/spark2014-docs/html/ug/gnatprove_by_example/manual_proof.html#manual-proof-using-user-lemmas][Manual Proof
Examples]].

**** The Swap_Array procedure

In order to prove the loop invariant, we want to write a
procedure which takes an array and two indexes as parameters,
swaps the two values found at these indexes, and prove that this
operation is a permutation on the array. Its specification would
then be:

#+BEGIN_SRC ada
  procedure Swap_Array
    (A : in out T_Arr;
     J :        Positive;
     K :        Positive) with
     Pre  => A'Length >= 1 and then J in A'Range and then K in A'Range,
     Post => A'Old (J) = A (K) and then A'Old (K) = A (J)
     and then
     (for all L in A'Old'Range =>
        (if J /= L and then K /= L then A'Old (L) = A (L)))
     and then Multiset_Unchanged (A'Old, A);
#+END_SRC

The precondition simply expresses that ~J~ and ~K~ are valid
indexes. The postconditions express that:
- the values at indexes ~J~ and ~K~ were swapped
- all values found a indexes different to ~J~ and ~K~ remain
  unchanged
- the resulting array is a permutation of the input array

The implementation (without SPARK annotations) is quite
straightforward:

#+BEGIN_SRC ada
  function Swap_Array (A : T_Arr; I : Positive;
  		     J : Positive) return T_Arr is
      Temp : T := A(I);
  begin
      A(I) := A(J);
      A(J) := Temp;
  end Swap_Array;
#+END_SRC

With this current implementation, the desired result is
achieved, but the last postcondition on ~Multiset_Unchanged~ is
still not proved. We have to write a lemma that will help
solvers to prove this property.

**** The Is_Set predicate

We define first the ~Is_Set~ predicate as follows:

#+BEGIN_SRC ada
  function Is_Set
    (A : T_Arr;
     J : Positive;
     V : T;
     B : T_Arr)
     return Boolean is
    (A'First = B'First and then A'Last = B'Last and then B (J) = V
     and then (for all K in A'Range => (if J /= K then B (K) = A (K)))) with
     Pre => J in A'Range;
#+END_SRC

The ~Is_Set~ predicate verifies that ~B~ is equal to ~A~, except
for the value found at index ~I~, which should be equal to
~V~. This predicate will be useful when comparing the
occurrences of some values before and after an array has changed
(when swapping two values for instance).

**** The Occ_Set lemma

~Occ_Set~ is a lemma defining the relation between the
occurrences of a given value in an array before and after
changing one of its indexes. Its specification is as follows:

#+BEGIN_SRC ada
  procedure Occ_Set
    (A : T_Arr;
     B : T_Arr;
     J : Positive;
     V : T;
     E : T) with
     Pre  => J in A'Range and then Is_Set (A, J, V, B),
     Post =>
     (if V = A (J) then Occ (B, E) = Occ (A, E)
      elsif V = E then Occ (B, E) = Occ (A, E) + 1
      elsif A (J) = E then Occ (B, E) = Occ (A, E) - 1
      else Occ (B, E) = Occ (A, E));
#+END_SRC

The precondition expresses the fact that ~B~ should be equal to
~A~, except for the value at index ~J~ which should be equal to
~V~. The postconditions are the mathematical relations we expect
to find concerning the number of occurrences of a given value
~E~ in ~A~ and ~B~:

- if ~V~ is the value of ~A (J)~, then nothing has changed for
  ~E~
- if ~E~ is in fact ~V~, then there is an extra occurrence of
  ~E~ in ~B~
- if ~E~ is the value of ~A (J)~, then ~B~ lose one occurrence
  of ~E~
- otherwise nothing has changed for ~E~

The proof of the lemma is given in its implementation:

#+BEGIN_SRC ada
  procedure Occ_Set
    (A : T_Arr;
     B : T_Arr;
     J : Positive;
     V : T;
     E : T)
  is
     Tmp : T_Arr := Remove_Last (A);
  begin
     if A'Length = 0 then
        return;
     end if;
  
     if J = A'Last then
        Occ_Equal (Tmp, Remove_Last (B), E);
     else
        Tmp (J) := V;
        Occ_Equal (Remove_Last (B), Tmp, E);
        Occ_Set (Remove_Last (A), Tmp, J, V, E);
     end if;
  end Occ_Set;
#+END_SRC

The proof is once again inductive and use ~Remove_Last~ as
usual:
- if ~A~ is empty then there is nothing to prove
- if ~J~ is equal to ~A'Last~, i.e. ~A~ and ~B~ only differ on
  their last index, then we verify that the number of occurrences
  of ~E~ is equal on both arrays on the rest of the indexes. The
  provers can then deduce the postconditions depending on the
  values of ~E~ and ~V~.
- If ~J~ isn't equal to ~A'Last~, then we call ~Occ_Eq~ on the
  first indexes of ~B~ and on the first indexes of ~A~, but with
  the value at index ~J~ equal to ~V~ (see the array
  ~Tmp~). This tells the solvers that ~Tmp = Remove_Last (B)~,
  and can deduce that the contribution of the last index is the
  same in ~Occ(A,E)~ and ~Occ(B,E)~. We then proceed to prove
  the property on the rest of the indexes.

With this lemmas proved, we can now move on to the proof of the
last postcondition of ~Swap_Array~.

**** The Prove_Perm procedure

We will write a ghost procedure which will guide the automatic
solvers to verify our last postcondition. This procedure will be
written in the declarative part of ~Swap_Array~ so it can access
all the parameters and intermediate variables used in the
function. Notice that it could have been written in another
package. In this case, we would have to give the working arrays
as parameters to the ghost procedure.

Since we wrote the procedure in the declarative part of
~Swap_Array~ to be able to use all the working variables, we
need to look at the full implementation of ~Swap_Array~ in order
to understand how it works:

#+BEGIN_SRC ada
  procedure Prove_Perm with
     Ghost,
     Pre => J in A'Range and then K in A'Range
     and then Is_Set (A_Init, J, A_Init (K), A_After_First)
     and then Is_Set (A_After_First, K, A_Init (J), A),
     Post => Multiset_Unchanged (A_Init, A)
   is
  begin
     for V in T loop
        Occ_Set (A_Init, A_After_First, J, A_Init (K), V);
        Occ_Set (A_After_First, A, K, A_Init (J), V);
        pragma Loop_Invariant
  	(for all F in T'First .. V => Occ (A_Init, F) = Occ (A, F));
     end loop;
  end Prove_Perm;
#+END_SRC

We first declare a ghost variable ~A_After_First~ which will
hold the state of the array ~A~ on which we do the swap, after
the first value assignment. An array ~A_Init~ is a copy of ~A~
at the beginning of the procedure.

The proof procedure, called here ~Prove_Perm~ requires that ~J~
and ~K~ are valid indexes, that ~A_After_First~ should be equal
to ~A_Init~, except for index ~J~ which should have the value
~A_Init (K)~, and that ~A~ should be equal to ~A_After_First~,
except for the value at index ~K~ which should be equal to
~A_Init (J)~. The postcondition of this procedure is what we are
trying to prove, i.e. that ~A~ is now a permutation of ~A_Init~.

To establish the postcondition, we will manually apply the
~Occ_Set~ lemma on all values ~V~ of ~T~ concerning the number
of occurrences of ~V~ in the arrays.  This is done inside the
~for~ loop, and the loop invariant is here to accumulate the
results of our lemmas. Notice that when the loop reaches its
end, then ~V = T'Last~ and the loop invariant is ~for all E in
      T'First .. T'Last then Occ(Result,E) = Occ(A,E)~ which is
exactly the postcondition we are trying to prove.

We now have to use ~Prove_Perm~ in the body of ~Swap_Array~. We
just have to initialize ~A_After_First~ to the correct value,
assert the preconditions of the proof procedure, and then call
the proof procedure so that the solvers apply our proof
procedure to ~Swap_Array~:

#+BEGIN_SRC ada
  procedure Swap_Array
    (A : in out T_Arr;
     J :        Positive;
     K :        Positive)
  is
     A_Init : T_Arr (A'Range) := A;
     Temp   : T               := A (J);
  
     -- ghost variable
  
     A_After_First : T_Arr (A'Range) with
        Ghost;
  
        -- ghost procedure
  
     procedure Prove_Perm with
        Ghost,
        Pre => J in A'Range and then K in A'Range
        and then Is_Set (A_Init, J, A_Init (K), A_After_First)
        and then Is_Set (A_After_First, K, A_Init (J), A),
        Post => Multiset_Unchanged (A_Init, A)
      is
     begin
        for V in T loop
  	 Occ_Set (A_Init, A_After_First, J, A_Init (K), V);
  	 Occ_Set (A_After_First, A, K, A_Init (J), V);
  	 pragma Loop_Invariant
  	   (for all F in T'First .. V => Occ (A_Init, F) = Occ (A, F));
        end loop;
     end Prove_Perm;
  
  begin
     A (J)         := A (K);
     A_After_First := A; -- ghost code
  
     pragma Assert (Is_Set (A_Init, J, A_Init (K), A_After_First));
  
     A (K) := Temp;
  
     pragma Assert (Is_Set (A_After_First, K, A_Init (J), A));
     Prove_Perm; -- ghost code
  
  end Swap_Array;
#+END_SRC

**** Final implementation of Random_Shuffle

We can now give somewhat condensed and simple implementation of
~Random_Shuffle~:

#+BEGIN_SRC ada
  procedure Random_Shuffle (A : in out T_Arr) is
     J : Positive;
  begin
  
     for I in A'Range loop
        J := Random_Number (A'First, I);
  
        Swap_Array (A, I, J);
        pragma Loop_Invariant (Multiset_Unchanged (A, A'Loop_Entry));
  
     end loop;
  end Random_Shuffle;
#+END_SRC

We simply replace the ~Swap~ procedure by our newly coded
~Swap_Array~ function, and the only loop_invariant specify that
~A~ is a permutation of ~A'Loop_Entry~, which is exactly the
postcondition of our proof procedure ~Prove_Perm~ at the exit of
the loop.

With this implementation, ~GNATprove~ manages to prove
everything.

*** A word on the implementation of Random_Number

We did not look in detail how the random number generator is
specified and implemented when proving ~Random_Shuffle~.
Nevertheless, we present here a crude version of a random number
generator using the Ada numerics package. It should be noted that
the [[http://docs.adacore.com/spark2014-docs/html/lrm/the-standard-library.html#random-number-generation-a-5-2][SPARK 2014 reference manual]] indicates that using the package
~Ada.Numerics.Discrete_Random~ isn't forbidden in SPAKR 2014, but
the associated functions have side effects and cannot therefore
be formally proved. A better solution would be to manualy code a
random number generator, as it is done in [[https://github.com/fraunhoferfokus/acsl-by-example/blob/master/StandardAlgorithms/mutating/random_shuffle/random_number.c][ACSL by Example]]. Our
specification and implementation of ~Random_Number~ are:

#+BEGIN_SRC ada
  function Random_Number
    (First : Positive;
     Last  : Positive)
     return Positive with
     Pre  => Last >= First,
     Post => Random_Number'Result in First .. Last;
#+END_SRC

#+BEGIN_SRC ada
  function Random_Number
    (First : Positive;
     Last  : Positive)
     return Positive
  is
  
     subtype Rng is Positive range First .. Last;
     package Alea is new Ada.Numerics.Discrete_Random (Rng);
     use Alea;
  
     Rnd_Gen : Generator;
     Result  : Integer;
  
  begin
     Reset (Rnd_Gen);
     Result := Random (Rnd_Gen);
     if Result < First then
        Result := First;
     elsif Result > Last then
        Result := Last;
     end if;
  
     return Result;
  
  end Random_Number;
#+END_SRC

This implementation uses the package
~Ada.Numerics.Discrete_Random~ out of convenience and declares a
new random generator at each call of the function. This is
clearly not ideal because two calls with the same arguments close
enough in time would yield to the same result. Since two
consecutive calls to this function should be with different
parameters, we consider that this is not an issue.
